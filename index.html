<!DOCTYPE html>
<html lang="tr">
  <head>
    <meta charset="UTF-8" />
    <title>4H EMA 5-8-13-20 Trend Scanner</title>
    <style>
      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI',
          sans-serif;
        background: #0b0d10;
        color: #f5f5f5;
        margin: 0;
        padding: 16px;
      }
      h1 {
        font-size: 20px;
        margin-bottom: 4px;
      }
      .subtitle {
        font-size: 11px;
        color: #aaa;
        margin-bottom: 12px;
        line-height: 1.4;
      }
      table {
        border-collapse: collapse;
        width: 100%;
        font-size: 13px;
      }
      th,
      td {
        border: 1px solid #333;
        padding: 6px 8px;
        text-align: left;
      }
      td a {
        text-decoration: none;
        color: inherit;
      }
      td a:hover {
        text-decoration: underline;
      }
      th {
        background: #151821;
        position: sticky;
        top: 0;
        z-index: 1;
      }
      tr:nth-child(even) td {
        background: #14161d;
      }
      .ok {
        color: #00d97e;
        font-weight: 600;
      }
      .bad {
        color: #ff4d4d;
        font-weight: 600;
      }
      .neutral {
        color: #ccc;
      }
      .loading-row td {
        text-align: left;
        font-style: italic;
        color: #aaa;
      }
      .footer {
        margin-top: 10px;
        font-size: 11px;
        color: #777;
      }
      code {
        background: #151821;
        padding: 2px 4px;
        border-radius: 3px;
        font-size: 11px;
      }
      .trend-text {
        white-space: nowrap;
      }

      .badges {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
      }
      .badge {
        display: inline-block;
        padding: 2px 6px;
        border-radius: 999px;
        font-size: 11px;
        line-height: 1.2;
        border: 1px solid #333;
        background: #151821;
        color: #ddd;
        white-space: nowrap;
      }
      .badge-core {
        border-color: #2a5;
        color: #9f9;
      }
      .badge-growth {
        border-color: #58a;
        color: #bfe;
      }
      .badge-spec {
        border-color: #a85;
        color: #ffd0b0;
      }
      .badge-risk {
        border-color: #c44;
        color: #ffb3b3;
      }
      .badge-tag {
        border-color: #444;
        color: #ddd;
        opacity: 0.95;
      }

      /* Column show/hide (Tier=2, Tags=3) */
      #scannerTable.hide-tier th:nth-child(2),
      #scannerTable.hide-tier td:nth-child(2) {
        display: none;
      }
      #scannerTable.hide-tags th:nth-child(3),
      #scannerTable.hide-tags td:nth-child(3) {
        display: none;
      }
    </style>
  </head>
  <body>
    <h1>4H EMA 5-8-13-20 Trend Scanner</h1>
    <div class="subtitle">
      <div>
        <b>Koşul:</b>
        <code
          >close &gt; EMA5 &gt; EMA8 &gt; EMA13 &amp;&amp; close &gt; EMA20,
          RSI14 &gt; 50, Vol &gt; VolMA20</code
        >
      </div>
      <div>
        <b>Skor:</b>
        Trend OK = +5, RSI OK = +2, Hacim OK = +1 &nbsp;•&nbsp; Yakınlık bonusu:
        trendDiff×2.0, rsiDiff×0.5, volDiff×0.2
      </div>
      <div>
        30 saniyede bir otomatik yenilenir. Sıralama: en yüksek skordan en
        düşüğe.
      </div>
    </div>

    <div
      class="subtitle"
      style="
        margin-top: -6px;
        display: flex;
        gap: 12px;
        align-items: center;
        flex-wrap: wrap;
      "
    >
      <label><input id="chkCore" type="checkbox" checked /> core</label>
      <label><input id="chkGrowth" type="checkbox" checked /> growth</label>
      <label><input id="chkSpec" type="checkbox" /> spec</label>
      <label
        ><input id="chkExp" type="checkbox" /> experimental (WLFI/FF
        dahil)</label
      >

      <span style="opacity: 0.7">|</span>
      <label><input id="chkShowTier" type="checkbox" /> Tier</label>
      <label><input id="chkShowTags" type="checkbox" /> Tags</label>
    </div>

    <table id="scannerTable">
      <thead>
        <tr>
          <th>Coin</th>
          <th>Tier</th>
          <th>Tags</th>
          <th>Son Fiyat (4H close)</th>
          <th>Trend (EMA)</th>
          <th>RSI(14)</th>
          <th>Hacim</th>
          <th>Trend Modu 20/50/100/200</th>
          <th>Giriş OK?</th>
        </tr>
      </thead>
      <tbody id="scannerBody">
        <!-- JS dolduracak -->
      </tbody>
    </table>

    <div class="footer">
      Kaynak: Binance 4H klines • Çok sık yenileme API rate limitine
      takılabilir, sorun olursa intervali büyütebilirsin.
    </div>
    <script>
      // ================== AYARLAR ==================

      // ================== COIN DB (metadata'lı) ==================
      /**
       * tier:
       *  - core   : Majors + oturmuş altyapı/DeFi (izleme listemin omurgası)
       *  - growth : Güçlü ama daha volatil / döngüsel (core kadar “sakin” değil)
       *  - spec   : Erken aşama / seed tag / oturmamış (core’dan ayrı tutulur)
       *
       * categories: serbest etiket seti (filtrelemek için)
       */
      const COIN_DB = [
        // ---- Core Majors ----
        { name: 'BTC', symbol: 'BTCUSDT', tier: 'core', tags: ['major'] },
        { name: 'ETH', symbol: 'ETHUSDT', tier: 'core', tags: ['major'] },
        {
          name: 'BNB',
          symbol: 'BNBUSDT',
          tier: 'core',
          tags: ['major', 'exchange'],
        },
        { name: 'SOL', symbol: 'SOLUSDT', tier: 'core', tags: ['major', 'L1'] },
        {
          name: 'XRP',
          symbol: 'XRPUSDT',
          tier: 'core',
          tags: ['major', 'payments'],
        },

        // ---- Growth (oturmuş ama daha volatil) ----
        { name: 'ADA', symbol: 'ADAUSDT', tier: 'growth', tags: ['L1'] },
        { name: 'TRX', symbol: 'TRXUSDT', tier: 'growth', tags: ['L1'] },
        { name: 'DOGE', symbol: 'DOGEUSDT', tier: 'growth', tags: ['meme'] },
        {
          name: 'LTC',
          symbol: 'LTCUSDT',
          tier: 'growth',
          tags: ['legacy', 'payments'],
        },

        // ---- L1/L0 ----
        { name: 'AVAX', symbol: 'AVAXUSDT', tier: 'growth', tags: ['L1'] },
        { name: 'NEAR', symbol: 'NEARUSDT', tier: 'growth', tags: ['L1'] },
        { name: 'DOT', symbol: 'DOTUSDT', tier: 'growth', tags: ['L0'] },
        { name: 'ATOM', symbol: 'ATOMUSDT', tier: 'growth', tags: ['L0'] },
        { name: 'SUI', symbol: 'SUIUSDT', tier: 'growth', tags: ['L1'] },
        { name: 'TON', symbol: 'TONUSDT', tier: 'growth', tags: ['L1'] },
        {
          name: 'TIA',
          symbol: 'TIAUSDT',
          tier: 'growth',
          tags: ['modular', 'da'],
        },
        { name: 'APT', symbol: 'APTUSDT', tier: 'growth', tags: ['L1'] },
        {
          name: 'ICP',
          symbol: 'ICPUSDT',
          tier: 'growth',
          tags: ['compute', 'L1'],
        },
        {
          name: 'SEI',
          symbol: 'SEIUSDT',
          tier: 'spec',
          tags: ['L1'],
          risk: ['new'],
        },

        // Storage / BTC eco
        { name: 'FIL', symbol: 'FILUSDT', tier: 'growth', tags: ['storage'] },
        { name: 'AR', symbol: 'ARUSDT', tier: 'growth', tags: ['storage'] },
        {
          name: 'STX',
          symbol: 'STXUSDT',
          tier: 'growth',
          tags: ['btc_ecosystem'],
        },

        // Legacy (core dışı)
        { name: 'XLM', symbol: 'XLMUSDT', tier: 'spec', tags: ['legacy'] },
        { name: 'ALGO', symbol: 'ALGOUSDT', tier: 'spec', tags: ['legacy'] },
        { name: 'VET', symbol: 'VETUSDT', tier: 'spec', tags: ['legacy'] },
        { name: 'KAVA', symbol: 'KAVAUSDT', tier: 'spec', tags: ['defi'] },
        { name: 'DASH', symbol: 'DASHUSDT', tier: 'spec', tags: ['legacy'] },
        { name: 'NEO', symbol: 'NEOUSDT', tier: 'spec', tags: ['legacy'] },
        { name: 'EGLD', symbol: 'EGLDUSDT', tier: 'spec', tags: ['L1'] },

        // ---- L2 / Scaling ----
        {
          name: 'ARB',
          symbol: 'ARBUSDT',
          tier: 'core',
          tags: ['L2', 'ethereum'],
        },
        {
          name: 'OP',
          symbol: 'OPUSDT',
          tier: 'core',
          tags: ['L2', 'ethereum'],
        },
        {
          name: 'POL',
          symbol: 'POLUSDT',
          tier: 'growth',
          tags: ['L2', 'ethereum'],
        },
        {
          name: 'STRK',
          symbol: 'STRKUSDT',
          tier: 'growth',
          tags: ['L2', 'zk'],
        },
        {
          name: 'ZK',
          symbol: 'ZKUSDT',
          tier: 'spec',
          tags: ['L2', 'zk'],
          risk: ['new'],
        },
        {
          name: 'LINEA',
          symbol: 'LINEAUSDT',
          tier: 'spec',
          tags: ['L2', 'zk'],
          risk: ['new'],
        },
        {
          name: 'IMX',
          symbol: 'IMXUSDT',
          tier: 'growth',
          tags: ['L2', 'gaming'],
        },

        // ---- DeFi ----
        { name: 'UNI', symbol: 'UNIUSDT', tier: 'core', tags: ['defi', 'dex'] },
        {
          name: 'AAVE',
          symbol: 'AAVEUSDT',
          tier: 'core',
          tags: ['defi', 'lending'],
        },
        {
          name: 'SNX',
          symbol: 'SNXUSDT',
          tier: 'growth',
          tags: ['defi', 'perps'],
        },
        {
          name: 'GMX',
          symbol: 'GMXUSDT',
          tier: 'growth',
          tags: ['defi', 'perps'],
        },
        {
          name: 'DYDX',
          symbol: 'DYDXUSDT',
          tier: 'growth',
          tags: ['defi', 'perps'],
        },
        {
          name: 'COMP',
          symbol: 'COMPUSDT',
          tier: 'spec',
          tags: ['defi', 'lending'],
        },
        {
          name: '1INCH',
          symbol: '1INCHUSDT',
          tier: 'spec',
          tags: ['defi', 'aggregator'],
        },
        {
          name: 'RAY',
          symbol: 'RAYUSDT',
          tier: 'spec',
          tags: ['defi', 'solana'],
        },
        {
          name: 'CRV',
          symbol: 'CRVUSDT',
          tier: 'growth',
          tags: ['defi', 'stableswap'],
        },
        {
          name: 'CVX',
          symbol: 'CVXUSDT',
          tier: 'growth',
          tags: ['defi', 'curve'],
        },
        {
          name: 'PENDLE',
          symbol: 'PENDLEUSDT',
          tier: 'growth',
          tags: ['defi', 'yield'],
        },
        { name: 'ONDO', symbol: 'ONDOUSDT', tier: 'growth', tags: ['rwa'] },
        {
          name: 'RUNE',
          symbol: 'RUNEUSDT',
          tier: 'growth',
          tags: ['defi', 'cross_chain'],
        },
        {
          name: 'INJ',
          symbol: 'INJUSDT',
          tier: 'growth',
          tags: ['defi', 'perps'],
        },

        // ---- LSD / Restaking ----
        { name: 'LDO', symbol: 'LDOUSDT', tier: 'core', tags: ['lsd'] },
        {
          name: 'ETHFI',
          symbol: 'ETHFIUSDT',
          tier: 'growth',
          tags: ['restaking'],
        },
        {
          name: 'ENA',
          symbol: 'ENAUSDT',
          tier: 'growth',
          tags: ['defi', 'stable'],
        },

        // ---- Oracle / Data ----
        { name: 'LINK', symbol: 'LINKUSDT', tier: 'core', tags: ['oracle'] },
        { name: 'PYTH', symbol: 'PYTHUSDT', tier: 'growth', tags: ['oracle'] },
        {
          name: 'BAND',
          symbol: 'BANDUSDT',
          tier: 'spec',
          tags: ['oracle', 'legacy'],
        },
        { name: 'GRT', symbol: 'GRTUSDT', tier: 'growth', tags: ['data'] },

        // ---- AI / Compute ----
        { name: 'FET', symbol: 'FETUSDT', tier: 'growth', tags: ['ai'] },
        { name: 'TAO', symbol: 'TAOUSDT', tier: 'growth', tags: ['ai'] },
        {
          name: 'RENDER',
          symbol: 'RENDERUSDT',
          tier: 'growth',
          tags: ['compute'],
        },
        { name: 'ARKM', symbol: 'ARKMUSDT', tier: 'spec', tags: ['data'] },

        // ---- Gaming/Meta (spec taraf) ----
        {
          name: 'SAND',
          symbol: 'SANDUSDT',
          tier: 'spec',
          tags: ['gaming', 'meta'],
        },
        {
          name: 'MANA',
          symbol: 'MANAUSDT',
          tier: 'spec',
          tags: ['gaming', 'meta'],
        },
        { name: 'AXS', symbol: 'AXSUSDT', tier: 'spec', tags: ['gaming'] },
        {
          name: 'ENJ',
          symbol: 'ENJUSDT',
          tier: 'spec',
          tags: ['gaming', 'legacy'],
        },

        // ---- Infra ----
        {
          name: 'ENS',
          symbol: 'ENSUSDT',
          tier: 'growth',
          tags: ['infra', 'identity'],
        },
      ];

      // Core’dan ayrı: “riskli/deneysel”
      const EXPERIMENTAL = [
        {
          name: 'WLFI',
          symbol: 'WLFIUSDT',
          tier: 'spec',
          tags: ['defi'],
          risk: ['seed_tag'],
        },
        {
          name: 'FF',
          symbol: 'FFUSDT',
          tier: 'spec',
          tags: ['defi'],
          risk: ['new'],
        },
      ];

      // Varsayılan: core+growth taransın, spec acik, experimental acik
      let SCAN_SETTINGS = {
        core: true,
        growth: true,
        spec: true,
        experimental: true,
      };

      function getActiveCoins() {
        const base = COIN_DB.filter((c) => SCAN_SETTINGS[c.tier] === true);
        return SCAN_SETTINGS.experimental ? [...base, ...EXPERIMENTAL] : base;
      }

      function bindFilters() {
        const $ = (id) => document.getElementById(id);

        const applyColumns = () => {
          const table = $('scannerTable');
          if (!table) return;

          const showTier = $('chkShowTier')?.checked ?? true;
          const showTags = $('chkShowTags')?.checked ?? true;

          table.classList.toggle('hide-tier', !showTier);
          table.classList.toggle('hide-tags', !showTags);
        };

        const apply = () => {
          SCAN_SETTINGS = {
            core: $('chkCore')?.checked ?? true,
            growth: $('chkGrowth')?.checked ?? true,
            spec: $('chkSpec')?.checked ?? false,
            experimental: $('chkExp')?.checked ?? false,
          };
          applyColumns();
          runScanner();
        };

        // Initial apply (in case defaults differ)
        applyColumns();

        [
          'chkCore',
          'chkGrowth',
          'chkSpec',
          'chkExp',
          'chkShowTier',
          'chkShowTags',
        ].forEach((id) => {
          const el = $(id);
          if (el) el.addEventListener('change', apply);
        });
      }
      const EMA_LENGTHS = [5, 8, 13, 20, 50, 100, 200];
      const RSI_LEN = 14;
      const VOL_MA_LEN = 20;
      const INTERVAL = '4h';
      const KLINE_LIMIT = 300; // history

      // ================== YARDIMCI FONKSİYONLAR ==================

      function ema(values, length) {
        const k = 2 / (length + 1);
        const emaArr = [];
        const n = values.length;
        if (n === 0) return emaArr;
        if (n < length) {
          // veri yetersizse basit fallback
          let prev = values[0];
          emaArr.push(prev);
          for (let i = 1; i < n; i++) {
            prev = values[i] * k + prev * (1 - k);
            emaArr.push(prev);
          }
          return emaArr;
        }

        // 1) İlk length barın SMA’sı
        let sum = 0;
        for (let i = 0; i < length; i++) sum += values[i];
        let prevEma = sum / length;

        // İlk (length-1) bar için NaN, length-1 için SMA
        for (let i = 0; i < length - 1; i++) emaArr.push(NaN);
        emaArr.push(prevEma);

        // 2) Sonraki barlar için klasik EMA
        for (let i = length; i < n; i++) {
          prevEma = values[i] * k + prevEma * (1 - k);
          emaArr.push(prevEma);
        }

        return emaArr;
      }

      function sma(values, length) {
        const out = [];
        let sum = 0;
        for (let i = 0; i < values.length; i++) {
          sum += values[i];
          if (i >= length) sum -= values[i - length];
          out.push(i >= length - 1 ? sum / length : NaN);
        }
        return out;
      }

      function rsi(values, length) {
        const gains = [];
        const losses = [];
        for (let i = 1; i < values.length; i++) {
          const diff = values[i] - values[i - 1];
          gains.push(Math.max(diff, 0));
          losses.push(Math.max(-diff, 0));
        }

        let avgGain = 0,
          avgLoss = 0;
        for (let i = 0; i < length; i++) {
          avgGain += gains[i];
          avgLoss += losses[i];
        }
        avgGain /= length;
        avgLoss /= length;

        const rsiArr = [NaN, ...Array(length - 1).fill(NaN)];
        let rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
        rsiArr.push(100 - 100 / (1 + rs));

        for (let i = length; i < gains.length; i++) {
          avgGain = (avgGain * (length - 1) + gains[i]) / length;
          avgLoss = (avgLoss * (length - 1) + losses[i]) / length;
          rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
          rsiArr.push(100 - 100 / (1 + rs));
        }

        while (rsiArr.length < values.length) rsiArr.unshift(NaN);
        return rsiArr;
      }

      function formatPrice(x) {
        if (!isFinite(x)) return '-';
        if (x >= 100) return x.toFixed(2);
        if (x >= 1) return x.toFixed(3);
        return x.toFixed(5);
      }

      function formatRsi(x) {
        if (!isFinite(x)) return '-';
        return x.toFixed(1);
      }

      function formatVol(x) {
        if (!isFinite(x)) return '-';
        if (x >= 1e9) return (x / 1e9).toFixed(2) + 'B';
        if (x >= 1e6) return (x / 1e6).toFixed(2) + 'M';
        if (x >= 1e3) return (x / 1e3).toFixed(1) + 'K';
        return x.toFixed(0);
      }

      function statusClass(flag) {
        if (flag === true) return 'ok';
        if (flag === false) return 'bad';
        return 'neutral';
      }

      // Pozisyon rengi (en sağ sütun)
      function posClass(status) {
        if (status === 'LONG') return 'ok'; // yeşil
        if (status === 'SOFT') return 'neutral'; // sarı yapmak istersen CSS'te ayrı sınıf açarız
        if (status === 'EXIT') return 'bad'; // kırmızı
        return 'neutral'; // WAIT
      }

      function posLabel(status) {
        if (status === 'LONG') return 'AL (pozisyon açık)';
        if (status === 'SOFT') return 'AĞIRLIK AZALT';
        if (status === 'EXIT') return 'SAT / POZİSYON KAPALI';
        return 'BEKLE';
      }

      function escapeHtml(s) {
        return String(s).replace(
          /[&<>"']/g,
          (c) =>
            ({
              '&': '&amp;',
              '<': '&lt;',
              '>': '&gt;',
              '"': '&quot;',
              "'": '&#39;',
            }[c])
        );
      }

      function renderTierBadge(tier) {
        const t = tier || 'spec';
        const tierClass =
          t === 'core'
            ? 'badge-core'
            : t === 'growth'
            ? 'badge-growth'
            : 'badge-spec';
        return `<span class="badge ${tierClass}">${escapeHtml(t)}</span>`;
      }

      function renderTagBadges(tags, risk) {
        const ts = Array.isArray(tags) ? tags : [];
        const rs = Array.isArray(risk) ? risk : [];
        const tagBadges = ts
          .slice(0, 6)
          .map((t) => `<span class="badge badge-tag">${escapeHtml(t)}</span>`)
          .join('');
        const more =
          ts.length > 6
            ? `<span class="badge badge-tag">+${ts.length - 6}</span>`
            : '';
        const riskBadges = rs
          .map((r) => `<span class="badge badge-risk">${escapeHtml(r)}</span>`)
          .join('');
        return `<div class="badges">${tagBadges}${more}${riskBadges}</div>`;
      }

      // Binance klines: [ openTime, open, high, low, close, volume, ... ]
      async function fetchKlines(symbol) {
        const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${INTERVAL}&limit=${KLINE_LIMIT}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return res.json();
      }

      // ================== ANA LOJİK ==================

      async function analyzeCoin(coin) {
        try {
          const klines = await fetchKlines(coin.symbol);
          const closes = klines.map((k) => parseFloat(k[4]));
          const volumes = klines.map((k) => parseFloat(k[5]));
          const n = closes.length;
          if (n === 0) throw new Error('No data');

          // EMA, RSI, VolMA dizileri
          const emaAll = {};
          for (const len of EMA_LENGTHS) {
            emaAll[len] = ema(closes, len);
          }
          const rsiArr = rsi(closes, RSI_LEN);
          const volMaArr = sma(volumes, VOL_MA_LEN);

          // Her bar için sinyaller
          const emaTrendFlags = [];
          const rsiFlags = [];
          const volFlags = [];
          const longFlags = [];
          const softFlags = [];
          const exitFlags = [];

          for (let i = 0; i < n; i++) {
            const c = closes[i];
            const e5 = emaAll[5][i];
            const e8 = emaAll[8][i];
            const e13 = emaAll[13][i];
            const e20 = emaAll[20][i];
            const r = rsiArr[i];
            const v = volumes[i];
            const vma = volMaArr[i];

            const emaTrendOk = c > e5 && e5 > e8 && e8 > e13 && c > e20;

            const rsiOk = r > 50;
            const volOk = isFinite(vma) && v > vma;

            // Entry
            const longBar = emaTrendOk && rsiOk && volOk;

            // Soft Exit (Pine'daki ile aynı mantık)
            const softExitBar = emaTrendOk && (e5 < e8 || c < e5);

            // Hard Exit
            const exitBar = c < e13 || (e5 < e8 && e8 < e13);

            emaTrendFlags.push(emaTrendOk);
            rsiFlags.push(rsiOk);
            volFlags.push(volOk);
            longFlags.push(longBar);
            softFlags.push(softExitBar);
            exitFlags.push(exitBar);
          }

          const last = n - 1;

          const close = closes[last];
          const vol = volumes[last];
          const volMa = volMaArr[last];

          const ema5 = emaAll[5][last];
          const ema8 = emaAll[8][last];
          const ema13 = emaAll[13][last];
          const ema20 = emaAll[20][last];
          const ema50 = emaAll[50][last];
          const ema100 = emaAll[100][last];
          const ema200 = emaAll[200][last];

          const emaTrendOk = emaTrendFlags[last];
          const rsiVal = rsiArr[last];
          const rsiOk = rsiFlags[last];
          const volOk = volFlags[last];

          // 20/50/100/200 trend modu (bilgi)
          let trendMode = 'YOK';
          if (emaTrendOk) {
            if (close < ema50) {
              trendMode = 'Erken Trend (EMA20 üstü, EMA50 altı)';
            } else if (close >= ema50 && close < ema100) {
              trendMode = 'Orta Trend (EMA50 üstü, EMA100 altı)';
            } else if (close >= ema100 && close < ema200) {
              trendMode = 'Geniş Trend (EMA100 üstü, EMA200 altı)';
            } else if (close >= ema200) {
              trendMode = 'Uzun Trend (EMA200 üstü)';
            }
          }

          // ---- Pozisyon state machine ----
          let lastLong = -1;
          let lastSoft = -1;
          let lastExit = -1;

          for (let i = 0; i < n; i++) {
            if (longFlags[i]) lastLong = i;
            if (softFlags[i]) lastSoft = i;
            if (exitFlags[i]) lastExit = i;
          }

          let positionStatus = 'WAIT'; // WAIT | LONG | SOFT | EXIT

          if (lastLong === -1) {
            positionStatus = 'WAIT';
          } else if (lastExit >= lastLong) {
            positionStatus = 'EXIT';
          } else if (lastSoft >= lastLong) {
            positionStatus = 'SOFT';
          } else {
            positionStatus = 'LONG';
          }

          return {
            coin: coin.name,
            symbol: coin.symbol,
            tier: coin.tier,
            tags: coin.tags,
            risk: coin.risk || [],
            close,
            ema5,
            ema8,
            ema13,
            ema20,
            ema50,
            ema100,
            ema200,
            rsiVal,
            vol,
            volMa,
            emaTrendOk,
            rsiOk,
            volOk,
            trendMode,
            positionStatus,
          };
        } catch (err) {
          console.error('Error for', coin.symbol, err);
          return {
            coin: coin.name,
            symbol: coin.symbol,
            tier: coin.tier,
            tags: coin.tags,
            risk: coin.risk || [],
            error: true,
          };
        }
      }

      async function runScanner() {
        const tbody = document.getElementById('scannerBody');
        tbody.innerHTML = '';

        const activeCoins = getActiveCoins();

        activeCoins.forEach((c) => {
          const tr = document.createElement('tr');
          tr.classList.add('loading-row');
          tr.innerHTML = `
            <td>${c.name}</td>
            <td>${renderTierBadge(c.tier)}</td>
            <td>${renderTagBadges(c.tags, c.risk)}</td>
            <td colspan="6">Yükleniyor...</td>
          `;
          tbody.appendChild(tr);
        });

        const results = await Promise.all(activeCoins.map(analyzeCoin));

        // Sıralama: Trend > RSI > Vol + yakınlık
        results.forEach((r) => {
          if (!r.error) {
            let score = 0;
            if (r.emaTrendOk) score += 5;
            if (r.rsiOk) score += 2;
            if (r.volOk) score += 1;

            const trendDiff =
              isFinite(r.ema20) && r.ema20 !== 0
                ? (r.close - r.ema20) / r.ema20
                : 0;
            const rsiDiff = (r.rsiVal - 50) / 50;
            const volDiff =
              isFinite(r.volMa) && r.volMa !== 0
                ? (r.vol - r.volMa) / r.volMa
                : -1;

            score += trendDiff * 2.0 + rsiDiff * 0.5 + volDiff * 0.2;
            r.score = score;
          } else {
            r.score = -1;
          }
        });

        function positionPriority(status) {
          // Büyükten küçüğe sıralayacağımız için
          // en yüksek öncelik AL (LONG)
          if (status === 'LONG') return 3; // AL
          if (status === 'SOFT') return 2; // AĞIRLIK AZALT
          if (status === 'WAIT') return 1; // BEKLE
          if (status === 'EXIT') return 0; // SAT
          return 0;
        }

        // ...

        // Pozisyon tipine göre, sonra skora göre sırala
        results.sort((a, b) => {
          const pa = positionPriority(a.positionStatus || 'WAIT');
          const pb = positionPriority(b.positionStatus || 'WAIT');

          if (pa !== pb) {
            return pb - pa; // önce pozisyon önceliği
          }
          return b.score - a.score; // aynı grupta skora göre
        });
        tbody.innerHTML = '';

        for (const res of results) {
          const tr = document.createElement('tr');

          if (res.error) {
            tr.innerHTML = `
            <td>${res.coin}</td>
            <td>${renderTierBadge(res.tier)}</td>
            <td>${renderTagBadges(res.tags, res.risk)}</td>
            <td colspan="6" class="bad">Hata / Sembol yok (${res.symbol})</td>
          `;
          } else {
            const trendTextPrefix = res.emaTrendOk ? 'OK ' : 'X ';
            const trendText =
              trendTextPrefix +
              `close=${formatPrice(res.close)} &gt; ema5=${formatPrice(
                res.ema5
              )} &gt; ema8=${formatPrice(res.ema8)} &gt; ema13=${formatPrice(
                res.ema13
              )} &amp; close&gt;ema20=${formatPrice(res.ema20)} | ` +
              `ema50=${formatPrice(res.ema50)} | ema100=${formatPrice(
                res.ema100
              )} | ema200=${formatPrice(res.ema200)}`;

            const rsiText = `${res.rsiOk ? 'OK' : 'X'} (${formatRsi(
              res.rsiVal
            )})`;
            const volText = `${res.volOk ? 'OK' : 'X'} (${formatVol(
              res.vol
            )} &gt; ${formatVol(res.volMa)})`;

            tr.innerHTML = `
            <td><a target="_blank" href="https://www.tradingview.com/chart/2ORhnngY/?symbol=BINANCE%3A${
              res.symbol
            }">${res.coin}</a></td>
            <td>${renderTierBadge(res.tier)}</td>
            <td>${renderTagBadges(res.tags, res.risk)}</td>
            <td>${formatPrice(res.close)}</td>
            <td class="${statusClass(res.emaTrendOk)}">
              <span class="trend-text">${trendText}</span>
            </td>
            <td class="${statusClass(res.rsiOk)}">${rsiText}</td>
            <td class="${statusClass(res.volOk)}">${volText}</td>
            <td>${res.trendMode}</td>
            <td class="${posClass(res.positionStatus)}">${posLabel(
              res.positionStatus
            )}</td>
          `;
          }

          tbody.appendChild(tr);
        }
      }

      bindFilters();
      runScanner();
      setInterval(runScanner, 30000);
    </script>
  </body>
</html>
