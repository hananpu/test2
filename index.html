<!DOCTYPE html>
<html lang="tr">
  <head>
    <meta charset="UTF-8" />
    <title>4H EMA 5-8-13-20 Trend Scanner</title>
    <style>
      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI',
          sans-serif;
        background: #0b0d10;
        color: #f5f5f5;
        margin: 0;
        padding: 16px;
      }
      h1 {
        font-size: 20px;
        margin-bottom: 4px;
      }
      .subtitle {
        font-size: 11px;
        color: #aaa;
        margin-bottom: 12px;
        line-height: 1.4;
      }
      table {
        border-collapse: collapse;
        width: 100%;
        font-size: 13px;
      }
      th,
      td {
        border: 1px solid #333;
        padding: 6px 8px;
        text-align: left;
      }
      td a {
        text-decoration: none;
        color: inherit;
      }
      th {
        background: #151821;
        position: sticky;
        top: 0;
        z-index: 1;
      }
      tr:nth-child(even) td {
        background: #14161d;
      }
      .ok {
        color: #00d97e;
        font-weight: 600;
      }
      .bad {
        color: #ff4d4d;
        font-weight: 600;
      }
      .neutral {
        color: #ccc;
      }
      .loading-row td {
        text-align: left;
        font-style: italic;
        color: #aaa;
      }
      .footer {
        margin-top: 10px;
        font-size: 11px;
        color: #777;
      }
      code {
        background: #151821;
        padding: 2px 4px;
        border-radius: 3px;
        font-size: 11px;
      }
      .trend-text {
        white-space: nowrap;
      }
    </style>
  </head>
  <body>
    <h1>4H EMA 5-8-13-20 Trend Scanner</h1>
    <div class="subtitle">
      <div>
        <b>Koşul:</b>
        <code
          >close &gt; EMA5 &gt; EMA8 &gt; EMA13 &amp;&amp; close &gt; EMA20,
          RSI14 &gt; 50, Vol &gt; VolMA20</code
        >
      </div>
      <div>
        <b>Skor:</b>
        Trend OK = +5, RSI OK = +2, Hacim OK = +1 &nbsp;•&nbsp; Yakınlık bonusu:
        trendDiff×2.0, rsiDiff×0.5, volDiff×0.2
      </div>
      <div>
        30 saniyede bir otomatik yenilenir. Sıralama: en yüksek skordan en
        düşüğe.
      </div>
    </div>

    <table id="scannerTable">
      <thead>
        <tr>
          <th>Coin</th>
          <th>Son Fiyat (4H close)</th>
          <th>Trend (EMA)</th>
          <th>RSI(14)</th>
          <th>Hacim</th>
          <th>Trend Modu 20/50/100/200</th>
          <th>Giriş OK?</th>
        </tr>
      </thead>
      <tbody id="scannerBody">
        <!-- JS dolduracak -->
      </tbody>
    </table>

    <div class="footer">
      Kaynak: Binance 4H klines • Çok sık yenileme API rate limitine
      takılabilir, sorun olursa intervali büyütebilirsin.
    </div>
    <script>
      // ================== AYARLAR ==================

      const COINS = [
        // ================== MAJORS (Büyükler) ==================
        { name: 'BTC', symbol: 'BTCUSDT' }, // Bitcoin
        { name: 'ETH', symbol: 'ETHUSDT' }, // Ethereum
        { name: 'BNB', symbol: 'BNBUSDT' }, // BNB Chain
        { name: 'SOL', symbol: 'SOLUSDT' }, // Solana
        { name: 'XRP *', symbol: 'XRPUSDT' }, // XRP
        { name: 'LTC', symbol: 'LTCUSDT' }, // Litecoin
        { name: 'ADA', symbol: 'ADAUSDT' }, // Cardano
        { name: 'TRX', symbol: 'TRXUSDT' }, // Tron

        // ================== L1 / L0 / GENEL ALT YAPI ==================
        { name: 'AVAX', symbol: 'AVAXUSDT' }, // Avalanche
        { name: 'NEAR *', symbol: 'NEARUSDT' }, // NEAR
        { name: 'DOT', symbol: 'DOTUSDT' }, // Polkadot
        { name: 'SUI', symbol: 'SUIUSDT' }, // Sui
        { name: 'TON', symbol: 'TONUSDT' }, // Ton
        { name: 'TIA', symbol: 'TIAUSDT' }, // Celestia
        { name: 'APT', symbol: 'APTUSDT' }, // Aptos
        { name: 'ICP', symbol: 'ICPUSDT' }, // Internet Computer
        { name: 'SEI', symbol: 'SEIUSDT' }, // Sei
        { name: 'NEO', symbol: 'NEOUSDT' }, // Neo
        { name: 'EGLD', symbol: 'EGLDUSDT' }, // MultiversX (Elrond)
        { name: 'ALGO', symbol: 'ALGOUSDT' }, // Algorand
        { name: 'XLM', symbol: 'XLMUSDT' }, // Stellar
        { name: 'VET', symbol: 'VETUSDT' }, // VeChain
        { name: 'FIL', symbol: 'FILUSDT' }, // Filecoin
        { name: 'AR', symbol: 'ARUSDT' }, // Arweave
        { name: 'STX', symbol: 'STXUSDT' }, // Stacks
        { name: 'FTM', symbol: 'FTMUSDT' }, // Fantom
        { name: 'KAVA', symbol: 'KAVAUSDT' }, // Kava
        { name: 'DASH', symbol: 'DASHUSDT' }, // Eski ama proje var

        // ================== L2 / SCALING ==================
        { name: 'ARB', symbol: 'ARBUSDT' }, // Arbitrum
        { name: 'OP *', symbol: 'OPUSDT' }, // Optimism
        { name: 'STRK', symbol: 'STRKUSDT' }, // Starknet
        { name: 'POL', symbol: 'POLUSDT' }, // Polygon ekosistem yönetişim
        { name: 'LINEA', symbol: 'LINEAUSDT' }, // Linea (varsa, yoksa bu satırı silersin)
        { name: 'IMX', symbol: 'IMXUSDT' }, // Immutable X (gaming L2)

        // ================== DEFi / DEX / LENDING ==================
        { name: 'UNI', symbol: 'UNIUSDT' }, // Uniswap
        { name: 'FF', symbol: 'FFUSDT' }, // FF
        { name: 'WLFI', symbol: 'WLFIUSDT' }, // WLFI
        { name: 'AAVE', symbol: 'AAVEUSDT' }, // Aave
        { name: 'SNX', symbol: 'SNXUSDT' }, // Synthetix
        { name: 'GMX', symbol: 'GMXUSDT' }, // GMX perp DEX
        { name: 'CAKE', symbol: 'CAKEUSDT' }, // PancakeSwap
        { name: 'COMP', symbol: 'COMPUSDT' }, // Compound
        { name: 'DYDX', symbol: 'DYDXUSDT' }, // dYdX
        { name: '1INCH', symbol: '1INCHUSDT' }, // 1inch DEX aggregator
        { name: 'RAY', symbol: 'RAYUSDT' }, // Raydium
        { name: 'CRV', symbol: 'CRVUSDT' }, // Curve
        { name: 'PENDLE', symbol: 'PENDLEUSDT' }, // Pendle
        { name: 'ONDO', symbol: 'ONDOUSDT' }, // ONDO RWA
        { name: 'RUNE', symbol: 'RUNEUSDT' }, // THORChain
        { name: 'INJ', symbol: 'INJUSDT' }, // Injective

        // ================== LSD / RESTAKING / YIELD ==================
        { name: 'LDO', symbol: 'LDOUSDT' }, // Lido (sen LIDO demiştin, Binance: LDO)
        { name: 'ETHFI', symbol: 'ETHFIUSDT' }, // ether.fi
        { name: 'ENA', symbol: 'ENAUSDT' }, // Ethena

        // ================== ORACLE / DATA / INDEX ==================
        { name: 'LINK *', symbol: 'LINKUSDT' }, // Chainlink
        { name: 'PYTH', symbol: 'PYTHUSDT' }, // Pyth Network
        { name: 'BAND', symbol: 'BANDUSDT' }, // Band Protocol
        { name: 'GRT', symbol: 'GRTUSDT' }, // The Graph

        // ================== AI / MACHINE LEARNING / DATA ==================
        { name: 'FET', symbol: 'FETUSDT' }, // Fetch.ai / ASI
        { name: 'TAO *', symbol: 'TAOUSDT' }, // Bittensor
        { name: 'RENDER', symbol: 'RENDERUSDT' }, // Render Network (Binance sembolü RNDR)
        { name: 'ARKM', symbol: 'ARKMUSDT' }, // Arkham
        { name: 'OCEAN', symbol: 'OCEANUSDT' }, // Ocean Protocol

        // ================== RWA / TOKENİZE VARLIK / KURUMSAL ==================
        //{ name: 'ONDO', symbol: 'ONDOUSDT' }, // Tekrar etmemek istersen yukarıdakini bırak yeter
        // İstersen başka RWA coinleri buraya ekleyebilirsin (NXRA vs.), ben çöp eklemedim.

        // ================== GAMING / METAVERSE ==================
        { name: 'SAND', symbol: 'SANDUSDT' }, // The Sandbox
        { name: 'MANA', symbol: 'MANAUSDT' }, // Decentraland
        { name: 'AXS', symbol: 'AXSUSDT' }, // Axie Infinity
        //{ name: 'IMX', symbol: 'IMXUSDT' }, // Zaten yukarıda L2’de de var ama gaming L2 olduğu için burada da anlamlı

        // ================== NAME SERVICE / ALTYAPI ==================
        { name: 'ENS', symbol: 'ENSUSDT' }, // Ethereum Name Service

        //
        { name: 'DOGE *', symbol: 'DOGEUSDT' }, // DOGE
        { name: 'ENJ *', symbol: 'ENJUSDT' }, // ENJ
      ];

      const EMA_LENGTHS = [5, 8, 13, 20, 50, 100, 200];
      const RSI_LEN = 14;
      const VOL_MA_LEN = 20;
      const INTERVAL = '4h';
      const KLINE_LIMIT = 200; // history

      // ================== YARDIMCI FONKSİYONLAR ==================

      function ema(values, length) {
        const k = 2 / (length + 1);
        const emaArr = [];
        let prevEma = values[0];
        emaArr.push(prevEma);
        for (let i = 1; i < values.length; i++) {
          const curr = values[i] * k + prevEma * (1 - k);
          emaArr.push(curr);
          prevEma = curr;
        }
        return emaArr;
      }

      function sma(values, length) {
        const out = [];
        let sum = 0;
        for (let i = 0; i < values.length; i++) {
          sum += values[i];
          if (i >= length) sum -= values[i - length];
          out.push(i >= length - 1 ? sum / length : NaN);
        }
        return out;
      }

      function rsi(values, length) {
        const gains = [];
        const losses = [];
        for (let i = 1; i < values.length; i++) {
          const diff = values[i] - values[i - 1];
          gains.push(Math.max(diff, 0));
          losses.push(Math.max(-diff, 0));
        }

        let avgGain = 0,
          avgLoss = 0;
        for (let i = 0; i < length; i++) {
          avgGain += gains[i];
          avgLoss += losses[i];
        }
        avgGain /= length;
        avgLoss /= length;

        const rsiArr = [NaN, ...Array(length - 1).fill(NaN)];
        let rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
        rsiArr.push(100 - 100 / (1 + rs));

        for (let i = length; i < gains.length; i++) {
          avgGain = (avgGain * (length - 1) + gains[i]) / length;
          avgLoss = (avgLoss * (length - 1) + losses[i]) / length;
          rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
          rsiArr.push(100 - 100 / (1 + rs));
        }

        while (rsiArr.length < values.length) rsiArr.unshift(NaN);
        return rsiArr;
      }

      function formatPrice(x) {
        if (!isFinite(x)) return '-';
        if (x >= 100) return x.toFixed(2);
        if (x >= 1) return x.toFixed(3);
        return x.toFixed(5);
      }

      function formatRsi(x) {
        if (!isFinite(x)) return '-';
        return x.toFixed(1);
      }

      function formatVol(x) {
        if (!isFinite(x)) return '-';
        if (x >= 1e9) return (x / 1e9).toFixed(2) + 'B';
        if (x >= 1e6) return (x / 1e6).toFixed(2) + 'M';
        if (x >= 1e3) return (x / 1e3).toFixed(1) + 'K';
        return x.toFixed(0);
      }

      function statusClass(flag) {
        if (flag === true) return 'ok';
        if (flag === false) return 'bad';
        return 'neutral';
      }

      // Pozisyon rengi (en sağ sütun)
      function posClass(status) {
        if (status === 'LONG') return 'ok'; // yeşil
        if (status === 'SOFT') return 'neutral'; // sarı yapmak istersen CSS'te ayrı sınıf açarız
        if (status === 'EXIT') return 'bad'; // kırmızı
        return 'neutral'; // WAIT
      }

      function posLabel(status) {
        if (status === 'LONG') return 'AL (pozisyon açık)';
        if (status === 'SOFT') return 'AĞIRLIK AZALT';
        if (status === 'EXIT') return 'SAT / POZİSYON KAPALI';
        return 'BEKLE';
      }

      // Binance klines: [ openTime, open, high, low, close, volume, ... ]
      async function fetchKlines(symbol) {
        const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${INTERVAL}&limit=${KLINE_LIMIT}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return res.json();
      }

      // ================== ANA LOJİK ==================

      async function analyzeCoin(coin) {
        try {
          const klines = await fetchKlines(coin.symbol);
          const closes = klines.map((k) => parseFloat(k[4]));
          const volumes = klines.map((k) => parseFloat(k[5]));
          const n = closes.length;
          if (n === 0) throw new Error('No data');

          // EMA, RSI, VolMA dizileri
          const emaAll = {};
          for (const len of EMA_LENGTHS) {
            emaAll[len] = ema(closes, len);
          }
          const rsiArr = rsi(closes, RSI_LEN);
          const volMaArr = sma(volumes, VOL_MA_LEN);

          // Her bar için sinyaller
          const emaTrendFlags = [];
          const rsiFlags = [];
          const volFlags = [];
          const longFlags = [];
          const softFlags = [];
          const exitFlags = [];

          for (let i = 0; i < n; i++) {
            const c = closes[i];
            const e5 = emaAll[5][i];
            const e8 = emaAll[8][i];
            const e13 = emaAll[13][i];
            const e20 = emaAll[20][i];
            const r = rsiArr[i];
            const v = volumes[i];
            const vma = volMaArr[i];

            const emaTrendOk = c > e5 && e5 > e8 && e8 > e13 && c > e20;

            const rsiOk = r > 50;
            const volOk = isFinite(vma) && v > vma;

            // Entry
            const longBar = emaTrendOk && rsiOk && volOk;

            // Soft Exit (Pine'daki ile aynı mantık)
            const softExitBar = emaTrendOk && (e5 < e8 || c < e5);

            // Hard Exit
            const exitBar = c < e13 || (e5 < e8 && e8 < e13);

            emaTrendFlags.push(emaTrendOk);
            rsiFlags.push(rsiOk);
            volFlags.push(volOk);
            longFlags.push(longBar);
            softFlags.push(softExitBar);
            exitFlags.push(exitBar);
          }

          const last = n - 1;

          const close = closes[last];
          const vol = volumes[last];
          const volMa = volMaArr[last];

          const ema5 = emaAll[5][last];
          const ema8 = emaAll[8][last];
          const ema13 = emaAll[13][last];
          const ema20 = emaAll[20][last];
          const ema50 = emaAll[50][last];
          const ema100 = emaAll[100][last];
          const ema200 = emaAll[200][last];

          const emaTrendOk = emaTrendFlags[last];
          const rsiVal = rsiArr[last];
          const rsiOk = rsiFlags[last];
          const volOk = volFlags[last];

          // 20/50/100/200 trend modu (bilgi)
          let trendMode = 'YOK';
          if (emaTrendOk) {
            if (close < ema50) {
              trendMode = 'Erken Trend (EMA20 üstü, EMA50 altı)';
            } else if (close >= ema50 && close < ema100) {
              trendMode = 'Orta Trend (EMA50 üstü, EMA100 altı)';
            } else if (close >= ema100 && close < ema200) {
              trendMode = 'Geniş Trend (EMA100 üstü, EMA200 altı)';
            } else if (close >= ema200) {
              trendMode = 'Uzun Trend (EMA200 üstü)';
            }
          }

          // ---- Pozisyon state machine ----
          let lastLong = -1;
          let lastSoft = -1;
          let lastExit = -1;

          for (let i = 0; i < n; i++) {
            if (longFlags[i]) lastLong = i;
            if (softFlags[i]) lastSoft = i;
            if (exitFlags[i]) lastExit = i;
          }

          let positionStatus = 'WAIT'; // WAIT | LONG | SOFT | EXIT

          if (lastLong === -1) {
            positionStatus = 'WAIT';
          } else if (lastExit >= lastLong) {
            positionStatus = 'EXIT';
          } else if (lastSoft >= lastLong) {
            positionStatus = 'SOFT';
          } else {
            positionStatus = 'LONG';
          }

          return {
            coin: coin.name,
            symbol: coin.symbol,
            close,
            ema5,
            ema8,
            ema13,
            ema20,
            ema50,
            ema100,
            ema200,
            rsiVal,
            vol,
            volMa,
            emaTrendOk,
            rsiOk,
            volOk,
            trendMode,
            positionStatus,
          };
        } catch (err) {
          console.error('Error for', coin.symbol, err);
          return { coin: coin.name, symbol: coin.symbol, error: true };
        }
      }

      async function runScanner() {
        const tbody = document.getElementById('scannerBody');
        tbody.innerHTML = '';

        COINS.forEach((c) => {
          const tr = document.createElement('tr');
          tr.classList.add('loading-row');
          tr.innerHTML = `<td>${c.name}</td><td colspan="6">Yükleniyor...</td>`;
          tbody.appendChild(tr);
        });

        const results = await Promise.all(COINS.map(analyzeCoin));

        // Sıralama: Trend > RSI > Vol + yakınlık
        results.forEach((r) => {
          if (!r.error) {
            let score = 0;
            if (r.emaTrendOk) score += 5;
            if (r.rsiOk) score += 2;
            if (r.volOk) score += 1;

            const trendDiff =
              isFinite(r.ema20) && r.ema20 !== 0
                ? (r.close - r.ema20) / r.ema20
                : 0;
            const rsiDiff = (r.rsiVal - 50) / 50;
            const volDiff =
              isFinite(r.volMa) && r.volMa !== 0
                ? (r.vol - r.volMa) / r.volMa
                : -1;

            score += trendDiff * 2.0 + rsiDiff * 0.5 + volDiff * 0.2;
            r.score = score;
          } else {
            r.score = -1;
          }
        });

        function positionPriority(status) {
          // Büyükten küçüğe sıralayacağımız için
          // en yüksek öncelik AL (LONG)
          if (status === 'LONG') return 3; // AL
          if (status === 'SOFT') return 2; // AĞIRLIK AZALT
          if (status === 'WAIT') return 1; // BEKLE
          if (status === 'EXIT') return 0; // SAT
          return 0;
        }

        // ...

        // Pozisyon tipine göre, sonra skora göre sırala
        results.sort((a, b) => {
          const pa = positionPriority(a.positionStatus || 'WAIT');
          const pb = positionPriority(b.positionStatus || 'WAIT');

          if (pa !== pb) {
            return pb - pa; // önce pozisyon önceliği
          }
          return b.score - a.score; // aynı grupta skora göre
        });
        tbody.innerHTML = '';

        for (const res of results) {
          const tr = document.createElement('tr');

          if (res.error) {
            tr.innerHTML = `
            <td>${res.coin}</td>
            <td colspan="6" class="bad">Hata / Sembol yok (${res.symbol})</td>
          `;
          } else {
            const trendTextPrefix = res.emaTrendOk ? 'OK ' : 'X ';
            const trendText =
              trendTextPrefix +
              `close=${formatPrice(res.close)} &gt; ema5=${formatPrice(
                res.ema5
              )} &gt; ema8=${formatPrice(res.ema8)} &gt; ema13=${formatPrice(
                res.ema13
              )} &amp; close&gt;ema20=${formatPrice(res.ema20)} | ` +
              `ema50=${formatPrice(res.ema50)} | ema100=${formatPrice(
                res.ema100
              )} | ema200=${formatPrice(res.ema200)}`;

            const rsiText = `${res.rsiOk ? 'OK' : 'X'} (${formatRsi(
              res.rsiVal
            )})`;
            const volText = `${res.volOk ? 'OK' : 'X'} (${formatVol(
              res.vol
            )} &gt; ${formatVol(res.volMa)})`;

            tr.innerHTML = `
            <td><a target="blank" href="https://www.tradingview.com/chart/2ORhnngY/?symbol=BINANCE%3A${
              res.symbol
            }USDT">${res.coin}</a></td>
            <td>${formatPrice(res.close)}</td>
            <td class="${statusClass(res.emaTrendOk)}">
              <span class="trend-text">${trendText}</span>
            </td>
            <td class="${statusClass(res.rsiOk)}">${rsiText}</td>
            <td class="${statusClass(res.volOk)}">${volText}</td>
            <td>${res.trendMode}</td>
            <td class="${posClass(res.positionStatus)}">${posLabel(
              res.positionStatus
            )}</td>
          `;
          }

          tbody.appendChild(tr);
        }
      }

      runScanner();
      setInterval(runScanner, 30000);
    </script>
  </body>
</html>
